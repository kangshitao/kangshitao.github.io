

<!DOCTYPE html>
<html lang="zh-CN" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Java学习笔记11-Java集合 - Live And Learn</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  <meta name="keywords" content="hexo-blog,live and learn,kangshitao, Java,Java集合,HashMap,Collection,List,Set,Map">
  <meta name="description" content="一、Java集合框架概述1、概述Java集合像一种容器...">
  <meta name="author" content="Kangshitao">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_r673sha78lq.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/atelier-heath-light.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/monokai-sublime.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '[object Object]'
      },
      donate: {
        enable: true,
        alipay: 'https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/alipay.jpg',
        wechat: 'https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '心之所向，素履以往',
          typing: true,
          api: 'https://v2.jinrishici.com/one.json',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: '',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'normal'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: '/search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Live And Learn" type="application/atom+xml">
</head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">Java学习笔记11-Java集合</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/archives " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/post_image_11.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">Java学习笔记11-Java集合</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>四月 09, 2021</span>
      
        <span class="post-info-item">
          <i class="iconfont iconeye"></i><span id="/2021/04/09/java-note-1101/" class="leancloud" data-flag-title="Java学习笔记11-Java集合"></span>
        </span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>17798</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h1 id="一、Java集合框架概述"><a href="#一、Java集合框架概述" class="headerlink" title="一、Java集合框架概述"></a>一、Java集合框架概述</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p><strong>Java集合</strong>像一种容器，可以动态地把多个对象的引用放入容器中。</p>
<p>数组在存储方面的特点：</p>
<ul>
<li>数组初始化以后长度确定。</li>
<li>声明的类型决定了元素初始化时的类型。</li>
</ul>
<p>数组存储数据的缺点：</p>
<ul>
<li>初始化以后长度就不可变，不便于扩展。</li>
<li>提供的属性和方法少，不便于添加删除、插入等操作，效率不高，无法直接获取元素个数。</li>
<li>数据有序、可以重复，存储数据的特点单一。</li>
</ul>
<p><strong>Java集合类</strong>可以用户存储数量不等的多个<strong>对象</strong>，还可用于保存具有映射关系的关联数组。</p>
<h2 id="2、集合框架"><a href="#2、集合框架" class="headerlink" title="2、集合框架"></a>2、集合框架</h2><p>Java 集合框架图：</p>
<div align='center'>
    <img src='https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/java-note-1101_1.png'/>
    <img src='https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/java-note-1101_2.png'/>
</div>

<p>Java集合框架主要有两个接口，<code>Collection</code>接口和<code>Map</code>接口：</p>
<p><code>Collection</code>接口：单列集合，其包括以下几个接口</p>
<ul>
<li><code>List</code>接口：存储<strong>有序(指存储位置有序)、可重复</strong>的数据<ul>
<li>常用实现类为<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code></li>
</ul>
</li>
<li><code>Set</code>接口：存储<strong>无序、不可重复</strong>的数据<ul>
<li>常用实现类有<code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code></li>
</ul>
</li>
<li><code>Queue</code>接口：先进先出<ul>
<li>常用实现类有<code>LinkedList</code>、<code>PriorityQueue</code></li>
</ul>
</li>
</ul>
<p><code>Map</code>接口：<strong>双列集合，用来存储成对的(key-value)数据</strong></p>
<ul>
<li>常用实现类有<code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code>、<code>Hashtable</code>、<code>Properties</code></li>
</ul>
<blockquote>
<p><strong>无序性</strong>指的是存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</p>
</blockquote>
<h1 id="二、Collection接口方法"><a href="#二、Collection接口方法" class="headerlink" title="二、Collection接口方法"></a>二、Collection接口方法</h1><p>向<code>Collection</code>接口的实现类对象中添加数据时，要求此数据所在的类要重写<code>equals()</code>方法。</p>
<p><code>Collection</code>接口定义了能够用于<code>List</code>/<code>Set</code>/<code>Queue</code>的方法。包括以下方法：</p>
<p>1、添加元素：<code>add(Object obj)</code>、<code>addAll(Collection coll)</code><br>2、获取有效元素的个数：<code>int size()</code><br>3、清空集合：<code>void clear()</code><br>4、是否是空集合：<code>boolean isEmpty()</code><br>5、是否包含某个元素：</p>
<ul>
<li><code>boolean contains(Object obj)</code>：是通过元素的equals方法来判断是否是同一个对象</li>
<li><code>boolean containsAll(Collection c)</code>：也是调用元素的equals方法来比较。拿两个集合的元素挨个比较。</li>
</ul>
<p>6、删除：</p>
<ul>
<li><code>boolean remove(Object obj)</code>：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素。</li>
<li><code>boolean removeAll(Collection coll)</code>：取当前集合的差集。</li>
</ul>
<p>7、取两个集合的交集：<code>boolean retainAll(Collection c)</code>：把交集的结果存在当前集合中，不影响c本身</p>
<p>8、集合是否相等：<code>boolean equals(Object obj)</code></p>
<p>9、转成对象数组：<code>Object[] toArray()</code></p>
<blockquote>
<p>数组转换为集合，调用数组的<code>asList()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List arr1 = Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">123</span>, <span class="hljs-number">456</span>&#125;);<br>System.out.println(arr1.size());<span class="hljs-comment">//1，此时添加的是int[]数组对象引用，长度是1</span><br><br>List&lt;Integer&gt; arr2 = Arrays.asList(<span class="hljs-keyword">new</span> Integer[]&#123;<span class="hljs-number">123</span>, <span class="hljs-number">456</span>&#125;);<br>System.out.println(arr2.size());<span class="hljs-comment">//2，添加的是Integer数组，有两个元素</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p>10、获取对象哈希值：<code>hashCode()</code></p>
<p>11、遍历：<code>iterator()</code>，返回迭代器对象，用于集合遍历</p>
<h1 id="三、Iterator迭代器接口"><a href="#三、Iterator迭代器接口" class="headerlink" title="三、Iterator迭代器接口"></a>三、Iterator迭代器接口</h1><p><code>Collection</code>接口继承了<code>Iterator&lt;E&gt;</code>接口，该接口有<code>iterator()</code>方法，因此<code>Collection</code>的实现类都有这个方法，调用此方法返回一个实现了<code>Iterator</code>接口的对象，可以用于遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection coll = <span class="hljs-keyword">new</span> ArrayList(); <span class="hljs-comment">//以ArrayList为例</span><br>Iterator iterator = coll.iterator();  <span class="hljs-comment">//返回一个迭代器对象</span><br><span class="hljs-comment">// Iterator&lt;Integer&gt; iterator = coll.iterator();  //Iterator是泛型类</span><br><span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>    Object obj = iterator.next();<br>    <span class="hljs-keyword">if</span>(obj.equals(<span class="hljs-string">&quot;xxx&quot;</span>))&#123;<br>        iter.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Iterator接口的三个方法：</p>
<ul>
<li><code>boolean hasNext()</code>：判断是否有下一个值</li>
<li><code>E next()</code>：指针下移，并返回下移以后指向的值，E是泛型</li>
<li><code>void remove()</code>：移除当前指向的值。执行remove操作后，需要执行next才能进行下一步操作</li>
</ul>
<blockquote>
<p>迭代器指针初始第一个元素之前，需要next()操作才指向第一个值。</p>
<p>集合对象每次调用<code>iterator()</code>方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</p>
</blockquote>
<p>JDK 5.0新增了<code>foreach</code>循环，用于遍历集合、数组，foreach内部仍然使用了迭代器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">for (元素类型 局部变量：集合或数组对象)&#123;</span><br><span class="hljs-comment">	//方法体</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//遍历集合</span><br>ArrayList&lt;Integer&gt; a = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">for</span>(Integer i : a)&#123;<br>    System.out.println(i);<br>&#125;<br><span class="hljs-comment">//遍历数组</span><br><span class="hljs-keyword">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i:array)&#123;<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="四、Collection子接口一：List"><a href="#四、Collection子接口一：List" class="headerlink" title="四、Collection子接口一：List"></a>四、Collection子接口一：List</h1><h2 id="1、List接口方法"><a href="#1、List接口方法" class="headerlink" title="1、List接口方法"></a>1、List接口方法</h2><p>除了从<code>Collection</code>接口继承的方法以外，<code>List</code>接口还新增了一些<strong>根据索引操作集合元素</strong>的方法：</p>
<ul>
<li><p><code>void add(int index, Object ele)</code>:在index位置插入ele元素</p>
</li>
<li><p><code>boolean addAll(int index, Collection eles)</code>:从index位置开始将eles中的所有元素添加进来</p>
</li>
<li><p><code>Object get(int index)</code>:获取指定index位置的元素</p>
</li>
<li><p><code>int indexOf(Object obj)</code>:返回obj在集合中首次出现的位置</p>
</li>
<li><p><code>int lastIndexOf(Object obj)</code>:返回obj在当前集合中末次出现的位置</p>
</li>
<li><p><code>Object remove(int index)</code>:移除指定index位置的元素，并返回此元素</p>
<blockquote>
<p>List接口继承了Collection中的方法，包括<code>remove(Object obj)</code>方法。<code>remove(2)</code>默认认为是索引<code>2</code>，<code>remove(new Integer(2))</code>才认为删除的是对象。</p>
</blockquote>
</li>
<li><p><code>Object set(int index, Object ele)</code>:设置指定index位置的元素为ele</p>
</li>
<li><p><code>List subList(int fromIndex, int toIndex)</code>:返回从fromIndex到toIndex位置的子集合</p>
</li>
</ul>
<h2 id="2、实现类"><a href="#2、实现类" class="headerlink" title="2、实现类"></a>2、实现类</h2><p><code>List</code>存储<strong>有序的、可重复</strong>的数据，常用实现类，三者的对比：</p>
<ul>
<li><p><code>ArrayList</code>：List接口主要实现类，<strong>适合频繁查找</strong>；<strong>线程不安全</strong>，效率高；底层使用<strong>数组</strong>实现：<code>Object[] elementData</code>；扩容时默认为原来的1.5倍</p>
</li>
<li><p><code>LinkedList</code>：<strong>适合频繁插入、删除</strong>操作；<strong>线程不安全</strong>；底层使用<strong>双向链表存储</strong>；</p>
</li>
</ul>
<ul>
<li><code>Vector</code>：List接口的早期实现类，与ArrayList几乎相同；<strong>线程安全</strong>，因此效率低；底层同样使用数组实现；与ArrayList另一点不同是扩容时扩大为原来的2倍 (JDK15中，Vector和ArrayList扩容机制相同)。此外，Vector还有一个子类Stack。</li>
</ul>
<h2 id="3、ArrayList"><a href="#3、ArrayList" class="headerlink" title="3、ArrayList"></a>3、ArrayList</h2><p><code>ArrayList</code>对象在JDK 7.0和JDK 8.0中的创建过程不同，JDK 7.0中创建<code>ArrayList</code>对象类似于单例模式的饿汉式，8.0中类似于单例模式的懒汉式，延迟了数组的创建，节省内存。</p>
<ol>
<li><p>JDK 7.0中，创建<code>ArrayList</code>对象的过程：</p>
<p><code>ArrayList list = new ArrayList();</code>    初始化时底层创建<strong>长度是10</strong>的Object[]数组elementData<br><code>list.add(123);</code>    底层执行elementData[0] = new Integer(123);操作<br>…<br><code>list.add(11);</code>    如果此次的添加导致底层elementData数组容量不够，则扩容。<br>默认情况下，扩容为原来的容量的<code>1.5</code>倍，同时需要将原有数组中的数据复制到新的数组中。</p>
<p>结论：建议开发中使用带参的构造器：<code>ArrayList list = new ArrayList(int capacity)</code>，防止频繁扩容降低效率</p>
</li>
<li><p>JDK 8.0中，创建<code>ArrayList</code>对象过程：</p>
<p><code>ArrayList list = new ArrayList();</code>    底层Object[] elementData初始化为{}，并没有创建长度为10的数组</p>
<p><code>list.add(123);</code>    第一次调用add()时，底层才创建了<strong>长度10</strong>的数组，并将数据123添加到elementData[0]<br>…<br>后续的添加和扩容操作与JDK 7 无异。</p>
</li>
</ol>
<h2 id="4、LinkedList"><a href="#4、LinkedList" class="headerlink" title="4、LinkedList"></a>4、LinkedList</h2><p><code>LinkedList</code>类新增了其特有的方法，方便对双向链表操作：</p>
<ul>
<li><code>void addFirst(Object obj)</code></li>
<li><code>void addLast(Object obj)</code></li>
<li><code>Object getFirst()</code></li>
<li><code>Object getLast()</code></li>
<li><code>Object removeFirst()</code></li>
<li><code>Object removeLast()</code></li>
</ul>
<p>LinkedList创建对象的过程：</p>
<p><code>LinkedList list = new LinkedList();</code>    内部声明了<code>Node</code>类型的first和last属性，默认值为null<br><code>list.add(123);</code>    将123封装到Node中，创建了<code>Node</code>对象(创建链表节点，add方法用尾插法插入节点)。</p>
<p>其中，<code>LinkedList</code>的<strong>双向链表</strong>中的节点用<code>Node</code>表示，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;...</span>&#123;<br>    ...<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123; <span class="hljs-comment">//内部类：Node，构造每个链表节点</span><br>        E item;<br>        Node&lt;E&gt; next;<br>        Node&lt;E&gt; prev;<br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; <span class="hljs-comment">//构造器</span><br>            <span class="hljs-keyword">this</span>.item = element;<br>            <span class="hljs-keyword">this</span>.next = next;<br>            <span class="hljs-keyword">this</span>.prev = prev;<br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="五、Collection子接口二：Set"><a href="#五、Collection子接口二：Set" class="headerlink" title="五、Collection子接口二：Set"></a>五、Collection子接口二：Set</h1><h2 id="1、Set概述"><a href="#1、Set概述" class="headerlink" title="1、Set概述"></a>1、Set概述</h2><p><code>Set</code>接口是<code>Collection</code>的子接口，Set接口没有提供额外的方法。</p>
<p><code>Set</code>存储无序、不可重复的数据。添加相同的元素会添加失败。</p>
<p><code>Set</code>根据<code>equals</code>判断两个对象是否相同。</p>
<p><code>Set</code>接口的常用实现类有：</p>
<ul>
<li><code>HashSet</code>：是Set接口的主要实现类；线程不安全；可以存储null值<ul>
<li><code>LinkedHashSet</code>：<code>HashSet</code>的子类；遍历其内部数据时按照添加的顺序遍历，对于频繁的遍历操作效率高于<code>HashSet</code></li>
</ul>
</li>
<li><code>TreeSet</code>：按照添加对象的制定属性进行排序。</li>
</ul>
<p>向Set(主要指：<code>HashSet</code>、<code>LinkedHashSet</code>)中添加的数据，其所在的类一定要重写<code>hashCode()</code>和<code>equals()</code>。因为添加数据时要用到两个方法进行判断。</p>
<p>重写的<code>hashCode()</code>和<code>equals()</code>尽可能保持一致性：相等(equals返回true)的对象必须具有相等的散列码，不相等的对象尽量有不同的散列码。</p>
<blockquote>
<p>对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</p>
</blockquote>
<p>重写hashCode方法中，用到<code>31</code>这个数字的原因：</p>
<ul>
<li>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，哈希冲突出现的次数越少，查找起来效率也会提高。（减少哈希冲突）</li>
<li>并且31只占用5bits,相乘造成数据溢出的概率较小。</li>
<li>31可以由<code>i*31== (i&lt;&lt;5)-1</code>来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）</li>
<li>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突)</li>
</ul>
<blockquote>
<p>哈希冲突指不同的哈希值(不同的数据)通过哈希函数得到的哈希值(索引位置)是相同的。解决哈希冲突的方法有：开放地址法、链式地址法(HashMap采用的方法)、建立公共溢出区、再哈希法。</p>
</blockquote>
<h2 id="2、HashSet"><a href="#2、HashSet" class="headerlink" title="2、HashSet"></a>2、HashSet</h2><p><code>HashSet</code>底层采用<code>HashMap</code>实现，Set就是HashMap中的Key，Value是统一定义的空对象，源代码中的Value：<code>private static final Object PRESENT = new Object();</code></p>
<p>其底层原理和HashMap相同，使用了数组和链表（JDK8中加入了红黑树），具体见HashMap解析。</p>
<p>HashSet添加元素的过程，与HashMap相同，实现原理参考下文的<a href="#HashMap">HashMap</a>。</p>
<h2 id="3、TreeSet"><a href="#3、TreeSet" class="headerlink" title="3、TreeSet"></a>3、TreeSet</h2><p><code>TreeSet</code>中添加的数据要求是相同类的对象，其可以根据<strong>自然排序</strong>和<strong>定制排序</strong>两种方式排序。</p>
<p><code>TreeSet</code>中比较两个对象是否相同的标准是<code>compareTo()</code>/<code>compare()</code>返回0。</p>
<p><code>TreeSet</code>用<code>TreeMap</code>实现，底层使用红黑树结构存储数据。</p>
<p><strong>红黑树</strong>：</p>
<p>红黑树是一种自平衡的二叉查找树。红黑树牺牲部分平衡性，换取插入/删除操作时少量的旋转次数，但是搜索效率下降，总体性能优于AVL树（平衡二叉搜索树）。</p>
<p>红黑树定义：</p>
<ul>
<li>结点是红色或黑色。</li>
<li>根节点是黑色。</li>
<li>所有叶子节点都是黑色(叶子节点是NIL节点，即空对象)</li>
<li>每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）</li>
<li>从任意一个节点到其每个叶子节点的所有路径，包含相同数量的黑色节点。（保证了从根到叶子节点的最长路径不超过最短路径的两倍长，最多是两倍 ）</li>
</ul>
<h1 id="六、Map接口"><a href="#六、Map接口" class="headerlink" title="六、Map接口"></a>六、Map接口</h1><h2 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h2><p><code>Map</code>与<code>Collection</code>并列存在，用于保存具有<strong>映射关系</strong>的双列数据：<code>key-value</code>对。</p>
<p><code>Map</code>结构的理解：</p>
<ul>
<li><code>key</code>：使用<code>Set</code>存放key，无序，不可重复，key所在类必须重写<code>hashCode()</code>和<code>equals()</code>方法，因为添加数据时要用到，而Object类中的<code>hashCode()</code>没有方法体。</li>
<li><code>value</code>：用<code>Collection</code>存放，无序，可重复，value所在的类要重写<code>equals()</code>方法。</li>
<li><code>entry</code>：一个<code>key-value</code>构成一个<code>entry</code>，entry构成的集合是<code>Set</code>，是无序，不可重复的。</li>
<li>两个<code>key</code>相同需要保证：<strong>equals方法返回true</strong>并且<strong>hashCode得到的值相等</strong>：<ul>
<li>如果<code>a</code>和<code>b</code>相等，那么<code>a.equals(b)</code>一定为<code>true</code>，则<code>a.hashCode()</code>必须等于<code>b.hashCode()</code>；</li>
<li>如果<code>a</code>和<code>b</code>不相等，那么<code>a.equals(b)</code>一定为<code>false</code>，则<code>a.hashCode()</code>和<code>b.hashCode()</code>尽量不要相等。</li>
</ul>
</li>
</ul>
<p><code>Map</code>接口几个实现类的对比：</p>
<ul>
<li><code>HashMap</code>：Map的主要实现类；<strong>线程不安全</strong>，效率高；允许存储null的key和value<ul>
<li><code>LinkedHashMap</code>：HashMap子类，在原有的HashMap基础上添加了一对指针，指向前一个元素和后一个元素，因此可以按照添加的顺序遍历。对于频繁遍历操作，效率高于HashMap。</li>
</ul>
</li>
<li><code>TreeMap</code>：保证按照添加的key-value对进行排序，实现排序遍历；根据key进行自然排序或定制排序；底层使用红黑树</li>
<li><code>Hashtable</code>：原始的Map实现类；<strong>线程安全</strong>，效率低；不能存储null的key和value<ul>
<li><code>Properties</code>：Hashtable的子类，常用来处理配置文件，其key和value都是String类型。</li>
</ul>
</li>
</ul>
<h2 id="2、Map接口方法"><a href="#2、Map接口方法" class="headerlink" title="2、Map接口方法"></a>2、Map接口方法</h2><p>Map接口中定义的方法如下：</p>
<p>添加、删除、修改操作：</p>
<ul>
<li><code>V put(K key,V value)</code>：将指定key-value添加到(或修改)当前map对象中，并返回value的值</li>
<li><code>void putAll(Map m)</code>:将m中的所有key-value对存放到当前map中</li>
<li><code>V remove(Object key)</code>：移除指定key的key-value对，并返回value</li>
<li><code>boolean remove(Object key, Object value)</code>：移除指定key和value的key-value对，并返回boolean类型</li>
<li><code>void clear()</code>：清空当前map中的所有数据</li>
</ul>
<p>元素查询的操作：</p>
<ul>
<li><code>V get(Object key)</code>：获取指定key对应的value</li>
<li><code>V getOrDefault(Object key, V defaultValue)</code>：如果指定的key值不存在，返回defaultValue</li>
<li><code>boolean containsKey(Object key)</code>：是否包含指定的key</li>
<li><code>boolean containsValue(Object value)</code>：是否包含指定的value</li>
<li><code>int size()</code>：返回map中key-value对的个数</li>
<li><code>boolean isEmpty()</code>：判断当前map是否为空</li>
<li><code>boolean equals(Object obj)</code>：判断当前map和参数对象obj是否相等</li>
</ul>
<p>元视图操作的方法：</p>
<ul>
<li><p><code>Set&lt;K&gt; keySet()</code>：返回所有key构成的Set集合</p>
</li>
<li><p><code>Collection&lt;V&gt; values()</code>：返回所有value构成的Collection集合</p>
</li>
<li><p><code>Set&lt;Entry&lt;K,V&gt;&gt; entrySet()</code>：返回所有key-value对构成的Set集合</p>
</li>
</ul>
<h2 id="3、HashMap"><a href="#3、HashMap" class="headerlink" title="3、HashMap"></a>3、HashMap</h2><p><span id="HashMap"><code>HashMap</code></span>是Map接口最常用的实现类。在JDK 7.0版本和JDK 8.0版本中，<code>HashMap</code>的底层实现原理不同。</p>
<p><code>HashMap</code>中的<code>Entry数组</code>，这个数组中可以存储元素的位置称为“<code>桶(bucket)</code>”，每个<code>bucket</code>都有指定的索引，系统可以根据索引快速访问该<code>bucket</code>里存储的元素。</p>
<p><strong>JDK 7.0中创建HashMap对象的过程</strong>：</p>
<p><code>HashMap map = new HashMap();</code> 实例化，底层创建了<strong>长度是16</strong>的一维数组<strong>Entry[] table</strong>。<br><code>map.put(key1,value1);</code>执行put操作，首先，调用key1所在类的<code>hashCode()</code>和HashMap中的扰动方法<code>hash()</code>计算key1哈希值，此哈希值经过某种算法(<code>int index = (n - 1) &amp; hash;</code>)计算以后，得到在Entry数组中的存放位置。</p>
<ul>
<li>如果此位置上的数据为空，此时的key1-value1添加成功。 ——&gt;情况1</li>
<li>如果此位置上的数据不为空(<strong>哈希冲突/碰撞</strong>。此位置上的存在一个或多个数据以链表形式存在),比较key1和已经存在的一个或多个数据的哈希值（这里比较的是经过<code>hash()</code>方法计算得出的哈希值）：<ul>
<li>如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。——&gt;情况2</li>
<li>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法：<ul>
<li>如果equals()返回false：此时key1-value1添加成功。——&gt;情况3</li>
<li>如果equals()返回true：使用value1替换value2（如果在HashSet中，这种情况会添加失败，但是在Map中则是进行value覆盖）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</p>
<p><strong>关于HashMap的说明</strong></p>
<ul>
<li><p><code>hashCode()</code>得到原始的哈希值，Java中又使用了<code>hash()</code>方法进行扰动，得到哈希值以后没有直接作为索引(直接将哈希值作为索引，数值太大)，而是使用<code>与</code>操作计算在数组中的索引，JDK7和8中的计算索引方法相同：<code>int index = (table.length - 1) &amp; hash;</code></p>
</li>
<li><p>扰动函数<code>hash()</code>的作用（源码注释：JDK7中为了防止低效的哈希函数，JDK8中是为了解决JDK7中只考虑低位的缺陷），JDK8中，改变了<code>hash()</code>的实现，将哈希值的高位和低位混合，加大低位的随机性，从而在获得数组索引时减少冲突（这种冲突是由于计算索引值引起的），因为只算低位的话，就算哈希值不同，也可能得到相同的索引值引起冲突。如果是<code>hashCode()</code>计算出不同数据的哈希值相同（哈希冲突），<code>hash()</code>方法是解决不了的。<code>hash()</code>的具体解析可以参考<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20733617/answer/111577937">链接</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//JDK 7中的hash方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (useAltHashing) &#123;<br>            <span class="hljs-keyword">if</span> (k <span class="hljs-keyword">instanceof</span> String) &#123;<br>                <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);<br>            &#125;<br>            h = hashSeed;<br>        &#125;<br>        h ^= k.hashCode();<br>        h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>        <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>    &#125;&#125;<br><br><span class="hljs-comment">//JDK 8中的hash方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    &#125;<span class="hljs-comment">//将原始哈希值的高位和其本身异或，减少计算索引时出现的冲突。</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>哈希冲突指的是不同的数据映射到了相同的位置（不同数据的哈希值相同），在HashMap中出现冲突有两个原因，一个是<code>hashCode()</code>计算的哈希值相同引起的哈希冲突，另一个是不同哈希值但是经过索引计算映射到了同一个位置。JDK8中hashCode()得到的哈希值相同，则hash()得到的也相同，hashCode()得到的哈希值不同，那么hash()得到的值肯定也不同。</p>
</li>
<li><p>所以在添加数据时，如果此位置上已有数据（出现哈希冲突），需要判断哈希值（<code>hash()</code>返回值）是否相同，如果哈希值不同却出现在了同一个位置（情况2），是由于Java中计算索引的方法导致的，可以直接添加；如果哈希值相同（hashCode()计算出的哈希值相同引起哈希冲突），这时只能通过<code>equals()</code>方法比较是不是相同的数据，如果是相同的数据，则进行覆盖，否则就添加。</p>
</li>
</ul>
<p><strong>JDK 8.0创建HashMap对象与JDK 7.0其他的不同</strong>：</p>
<ul>
<li><p>new HashMap()初始化时，底层没有创建一个长度为16的数组，首次调用put()方法时才创建，这一点类比于ArrayList在两个版本的区别。</p>
</li>
<li><p>JDK 8.0<strong>底层数组是Node[]</strong>，而非Entry[]，实际上<strong>内部类Node</strong>实现了<strong>内部接口Entry</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;...</span>&#123;<br>    <span class="hljs-comment">//内部类Node</span><br>	<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>        Node&lt;K,V&gt; next; <br>        <span class="hljs-comment">//Node[]数组中每个位置存储一个Node对象，每个对象的next引用指向下一个元素</span><br>        <span class="hljs-comment">//在JDK 7中，同样，每个Entry[]数组的每个位置存储一个Entry对象，有next指针</span><br><br>        Node(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.hash = hash;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>            <span class="hljs-keyword">this</span>.next = next;<br>        &#125;<br>        ... <span class="hljs-comment">//内部类中的其他方法，比如实现的getKey()、getValue()等</span><br>    &#125;<br>    <span class="hljs-comment">//内部接口 Entry</span><br>    <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>        <span class="hljs-function">K <span class="hljs-title">getKey</span><span class="hljs-params">()</span></span>;<br>        <span class="hljs-function">V <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;<br>        ...<br>    &#125;<br>    ...<span class="hljs-comment">//HashMap中的其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>JDK 7.0底层结构是<strong>数组+链表</strong>，JDK 8.0底层结构是<strong>数组+链表+红黑树</strong>，因此添加到已有元素的位置上时，需要判断是链表节点还是树节点。</p>
</li>
<li><p>JDK 8.0中，当某个bucket的链表长度<code>&gt;8</code>，并且数组长度（容量,capacity,table的长度）<code>&gt;64</code>时，才将链表改为红黑树。如果仅是长度&gt;8，数组容量不到64，会进行扩容。</p>
</li>
<li><p>如果映射关系被移除，下次resize方法时判断树的节点个数<code>&lt;6</code>，会将树转为链表。这里为了避免树和链表频繁转换带来的效率损失，才使用6，而没有直接选择8。</p>
</li>
<li><p>形成链表时，和ArrayList相同（七上八下）。JDK 7.0中，冲突时使用头插法将新节点插入到链表，由于是线程不安全的，可能导致出现<strong>环形链表(链表死循环)</strong>。JDK 8.0使用尾插法解决了这一问题。</p>
</li>
</ul>
<p><strong>HashMap的重要常量</strong>：</p>
<ul>
<li><code>DEFAULT_INITIAL_CAPACITY</code>：HashMap的默认容量，<code>16</code></li>
<li><code>DEFAULT_LOAD_FACTOR</code>：HashMap的默认加载因子：<code>0.75</code></li>
<li><code>threshold</code>：扩容的临界值 = 容量 x 填充因子，比如<code>16*0.75=12</code></li>
<li><code>TREEIFY_THRESHOLD</code>：Bucket中链表长度大于改值时，就转化为红黑树：<code>8</code></li>
<li><code>MIN_TREEIFY_CAPACITY</code>：桶中的Node被树化时最小的hash表容量：<code>64</code></li>
<li><code>MAXIMUM_CAPACITY</code>：HashMap最大支持容量：<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.676ex" style="vertical-align: -0.338ex;" viewBox="0 -1006.6 1308.3 1152.1" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg" aria-labelledby="MathJax-SVG-1-Title">
<title id="MathJax-SVG-1-Title">2^{30}</title>
<defs aria-hidden="true">
<path stroke-width="1" id="E1-MJMAIN-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path>
<path stroke-width="1" id="E1-MJMAIN-33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path>
<path stroke-width="1" id="E1-MJMAIN-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path>
</defs>
<g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)" aria-hidden="true">
 <use xlink:href="#E1-MJMAIN-32" x="0" y="0"></use>
<g transform="translate(500,412)">
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-33"></use>
 <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-30" x="500" y="0"></use>
</g>
</g>
</svg></li>
<li><code>table</code>：存储元素的数组，总是2的n次幂</li>
<li><code>entrySet</code>：存储所有entry元素的集合（Set）</li>
<li><code>size</code>：存储的键值对的数量</li>
<li><code>modCount</code>：HashMap扩容和结构改变的次数。</li>
</ul>
<blockquote>
<p>链表长度大于8并且容量大于64时，才变为红黑树，为什么是8？为什么容量要大于64？</p>
<p>答：阈值为8是出于时间和空间两方面权衡。哈希值离散性理想情况下，链表长度达到8的几率很小，bin中的节点分布频率服从泊松分布，链表长度大于8的几率小于千万分之一，此情况下如果仍达到了8个节点，说明节点数以后很可能还会继续增加，需要使用红黑树优化查找效率。另一方面，树节点占用空间是普通节点的2倍，如果阈值太小，频繁使用树结构会造成空间浪费。</p>
<p>关于容量大于64，源码中解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">The smallest table capacity for which bins may be treeified.</span><br><span class="hljs-comment">(Otherwise the table is resized if too many nodes in a bin.)</span><br><span class="hljs-comment">Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts </span><br><span class="hljs-comment">between resizing and treeification thresholds.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>也就是说，为了避免扩容和树化阈值之间的冲突，至少需要4x8=32个bin，如果长度太小，树化以后，如果扩容可能还需要树化，降低了效率。底层数组容量一直是2的n次幂，要想保证32个位置有元素，考虑0.75负载因子，至少需要64的长度。</p>
</blockquote>
<p><strong>HashMap的扩容机制</strong>：</p>
<p>添加数据时，当<strong>当前存放的值（size）超出临界值（threshold）且要存放的位置非空时</strong>会扩容，默认的扩容方式是扩容为原来容量的2倍，然后重新计算旧数组中节点的存储位置并复制过去。由于是扩容为2倍，索引计算方式为哈希值和数组长度-1进行与操作，得到的新数组索引要么是原下标位置，要么是原下标+原数组大小。</p>
<p>JDK 7采用<strong>头插法</strong>将每个bucket上的链表依次取出并放到新数组指定的位置，结果是链表顺序会变反。并且在多线程的情况下，容易导致链表循环。想要线程安全，可以使用<code>ConcurrentHashMap</code></p>
<p>JDK 8采用<strong>尾插法</strong>，解决了链表循环的问题。</p>
<p><strong>Java的HashMap解决哈希冲突的方法</strong>：</p>
<ul>
<li>使用链地址法，链接相同位置上的数据。</li>
<li>使用2次扰动函数（源码中的<code>hash()</code>函数），将<code>hashCode()</code>得到的哈希值的高位和低位混合，加大低位的随机性，使哈希值映射到数组索引更平均。</li>
<li>JDK 8.0中又引入红黑树，进一步降低遍历的时间复杂度，使遍历更快</li>
</ul>
<p><strong>LinkedHashMap</strong></p>
<p><code>LinkedHashMap</code>是<code>HashMap</code>的子类，其在<code>HashMap</code>的存储基础上，使用双向链表记录添加元素的顺序。</p>
<p>与<code>LinkedHashSet</code>类似，<code>LinkedHashMap</code>可以维护<code>Map</code>的迭代顺序，迭代顺序与Key-value对插入顺序一致。</p>
<p><code>LinkedHashMap</code>中的存储结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br><span class="hljs-class"></span>&#123;<br>    ...<br>	<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>.<span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>        <span class="hljs-comment">//Entry有两个额外的指针，分别指向上一个和下一个节点</span><br>        Entry&lt;K,V&gt; before, after; <br>        Entry(<span class="hljs-keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-keyword">super</span>(hash, key, value, next);<br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>JDK 8中HashMap添加数据的过程源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;...</span>&#123;<br>    ...<br>	<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>        <span class="hljs-comment">//如果table为空，扩容</span><br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length; <br>        <span class="hljs-comment">//如果目标位置为空，创建新节点并添加</span><br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>            tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">//如果目标位置有值，进一步判断</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;K,V&gt; e; K k;<br>            <span class="hljs-comment">//如果目标位置的值，hash值和数据都相同，进行覆盖</span><br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<br>            <span class="hljs-comment">//如果目标位置的值和要添加的值不同，则添加。</span><br>            <span class="hljs-comment">//判断是链表节点还是树节点，如果是树节点，调用putTreeVal</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>            <span class="hljs-comment">//如果是链表节点，需要依次往下遍历</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//遍历当前链表</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                    <span class="hljs-comment">//如果到达链表尾部，则新建链表节点，并不马上插入节点</span><br>                    <span class="hljs-comment">//需要判断当前已有节点个数，是否需要树化</span><br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                        p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                        <span class="hljs-comment">//如果此时链表已经有了8个节点，调用treeifyBin树化</span><br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            <span class="hljs-comment">//此方法会额外判断table数组长度是否大于64，</span><br>                            <span class="hljs-comment">//如果大于64才构造红黑树，否则执行扩容操作</span><br>                            treeifyBin(tab, hash);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-comment">//如果找到和待添加的值相同的数据，则break</span><br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-comment">//如果既没有到达末尾，也没有找到相同数据，则将e赋给p，继续向后找</span><br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//进行value覆盖</span><br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                V oldValue = e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                    e.value = value;<br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        ++modCount;<br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            resize(); <span class="hljs-comment">//判断添加数据以后是否需要扩容</span><br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关于HashMap的常见问题，可以参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Young111/p/11519952.html">HashMap数据结构相关知识总结</a></p>
<h2 id="4、TreeMap"><a href="#4、TreeMap" class="headerlink" title="4、TreeMap"></a>4、TreeMap</h2><p>保证按照添加的<code>key-value</code>对进行排序，实现排序遍历。只考虑<code>key</code>的<strong>自然排序或定制排序</strong>。使用自然排序或定制排序的方法比较<code>key</code>的大小，而不是<code>equals()</code>方法。</p>
<p>底层使用红黑树结构。</p>
<h2 id="5、Hashtable"><a href="#5、Hashtable" class="headerlink" title="5、Hashtable"></a>5、Hashtable</h2><p><strong>HashMap 和 Hashtable 的区别</strong></p>
<ul>
<li>HashMap 是线程不安全的，Hashtable 是线程安全的；</li>
<li>由于线程安全，所以 Hashtable 的效率比不上 HashMap；</li>
<li>HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 Hashtable 不允许key和value的值为null；</li>
<li>HashMap 默认初始化数组的大小为16，Hashtable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1；</li>
<li>HashMap 在hashCode基础上需要重新计算 hash 值，而 Hashtable 直接使用对象的 hashCode。</li>
</ul>
<p><strong>Properties</strong></p>
<p><code>Properties</code>是<code>Hashtable</code>的子类，用于处理属性文件。</p>
<p>由于属性文件里的<code>key</code>、<code>value</code>都是字符串类型，所以<code>Properties</code>里的<code>key</code>和<code>value</code>都是字符串类型</p>
<p>存取数据时，建议使用<code>setProperty(String key,String value)</code>方法和<code>getProperty(String key)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Properties pros = <span class="hljs-keyword">new</span> Properties();<br>pros.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;jdbc.properties&quot;</span>));<br>String user = pros.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>System.out.println(user);<br></code></pre></td></tr></table></figure>
<h1 id="七、Collections工具类"><a href="#七、Collections工具类" class="headerlink" title="七、Collections工具类"></a>七、Collections工具类</h1><p>和操作数组的工具类<code>Arrays</code>类似，<code>Collections</code>是操作<code>Set</code>、<code>List</code>、<code>Map</code>等集合的工具类。</p>
<p><code>Collections</code>提供了一系列静态方法，用于对集合元素的排序、查询和修改等操作：</p>
<ul>
<li><code>reverse(List)</code>：反转 List 中元素的顺序</li>
<li><code>shuffle(List)</code>：对 List 集合元素进行随机排序</li>
<li><code>sort(List)</code>：根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li><code>sort(List，Comparator)</code>：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li><code>swap(List，int i， int j)</code>：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
<li><code>Object max(Collection)</code>：根据元素的自然顺序，返回给定集合中的最大元素</li>
<li><code>Object max(Collection，Comparator)</code>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li>
<li><code>Object min(Collection)</code></li>
<li><code>Object min(Collection，Comparator)</code></li>
<li><code>int frequency(Collection，Object)</code>：返回指定集合中指定元素的出现次数</li>
<li><code>void copy(List dest,List src)</code>：将src中的内容复制到dest中</li>
<li><code>boolean replaceAll(List list，Object oldVal，Object newVal)</code>：使用新值替换 List 对象的所有旧值</li>
</ul>
<p>此外，<code>Collections</code>类还提供了多个<code>synchronizedXxx()</code> 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题：</p>
<ul>
<li><code>static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c)</code></li>
<li><code>static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li>
<li><code>static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li>
<li><code>static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li>
<li><code>static &lt;K,V&gt; NavigableMap&lt;K,V&gt; synchronizedNavigableMap(NavigableMap&lt;K,V&gt; m)</code></li>
<li><code>static &lt;T&gt; NavigableSet&lt;T&gt; synchronizedNavigableSet(NavigableSet&lt;T&gt; s)</code></li>
<li><code>static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m)</code></li>
<li><code>static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s)</code></li>
</ul>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>Kangshitao</li>
    <li><strong>本文链接：</strong><a href="http://kangshitao.github.io/2021/04/09/java-note-1101/index.html" title="http:&#x2F;&#x2F;kangshitao.github.io&#x2F;2021&#x2F;04&#x2F;09&#x2F;java-note-1101&#x2F;index.html">http:&#x2F;&#x2F;kangshitao.github.io&#x2F;2021&#x2F;04&#x2F;09&#x2F;java-note-1101&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="https://cdn.jsdelivr.net/gh/kangshitao/BlogPicture@main/img/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul> 

        
  <nav class="nav">
    <a href="/2021/04/11/java-note-1201/"><i class="iconfont iconleft"></i>Java学习笔记12-泛型</a>
    <a href="/2021/04/05/java-note-1001/">Java学习笔记10-枚举类与注解<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<div id="valine"></div>
<script defer src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
  window.onload = function () {
    var loadValine = function () {
      new Valine({
        el: '#valine',
        app_id: "dVB32zRRBIgKa5WuB56mtboj-gzGzoHsz",
        app_key: "XipU873t8gkSypbwl1HWUARD",
        placeholder: "write comment content...",
        avatar: "mp",
        pageSize: "10",
        lang: "zh-CN",
      });
    }
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        loadValine();
		var title1="text=Live and Learn有新评论啦~ --by Valine"
		var SCKEY_Server="SCT21455TskriUeyliOqL6kHLhiCOMmlB"
		var ValineButton=document.getElementsByClassName("vsubmit vbtn")[0];
		function send_valine_Server(){
			var text="desp=";
			var pageurl=document.URL;
			var ptime=new Date();
			var vnick=document.getElementsByClassName("vnick vinput")[0].value;
			var veditor=document.getElementsByClassName("veditor vinput")[0].value;
			var data=text+"|昵称"+"|评论内容"+"|跳转链接"+"|评论时间"+"\n"+"|----|----|----|----|"+"\n"+"|"+vnick+"|"+veditor+"|"+pageurl+"|" +ptime.toLocaleString()+"|";
			var httpRequest = new XMLHttpRequest();//第一步：创建需要的对象
			httpRequest.open('POST', 'https://sctapi.ftqq.com/'+SCKEY_Server+'.send', true); //第二步：打开连接
			httpRequest.setRequestHeader("Content-type","application/x-www-form-urlencoded");//设置请求头 注：post方式必须设置请求头（在建立连接后设置请求头）
			httpRequest.send(title1+"&"+data);//发送请求 将请头体体写在send中
		};
		ValineButton.onclick=send_valine_Server;
      });
    } else {
      loadValine();
    }
  };
 
</script>


</section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">一、Java集合框架概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-text">2、集合框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Collection%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-text">二、Collection接口方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text">三、Iterator迭代器接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Collection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B8%80%EF%BC%9AList"><span class="toc-text">四、Collection子接口一：List</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81List%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-text">1、List接口方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">2、实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81ArrayList"><span class="toc-text">3、ArrayList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81LinkedList"><span class="toc-text">4、LinkedList</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Collection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%BA%8C%EF%BC%9ASet"><span class="toc-text">五、Collection子接口二：Set</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Set%E6%A6%82%E8%BF%B0"><span class="toc-text">1、Set概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81HashSet"><span class="toc-text">2、HashSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81TreeSet"><span class="toc-text">3、TreeSet</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81Map%E6%8E%A5%E5%8F%A3"><span class="toc-text">六、Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0-1"><span class="toc-text">1、概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Map%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-text">2、Map接口方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81HashMap"><span class="toc-text">3、HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81TreeMap"><span class="toc-text">4、TreeMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Hashtable"><span class="toc-text">5、Hashtable</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">七、Collections工具类</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=1574716653 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://github.com/kangshitao "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#24292E'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:1574716653@qq.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span id="busuanzi_container_site_pv">Total:
  <span id="busuanzi_value_site_pv" style="font-size:12px;"></span></span>
  <span id="busuanzi_container_site_uv" >| Visitors:
  <span id="busuanzi_value_site_uv" style="font-size:12px;"></span></span>
  </div>
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
  
  
<script src="/js/clicklove.js"></script>
<!-- 页面点击小红心 -->
  
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>



  <script>
  $.getScript("//cdn.jsdelivr.net/npm/leancloud-storage@4.1.0/dist/av-min.js", () => {

    AV.init({
      appId: 'dVB32zRRBIgKa5WuB56mtboj-gzGzoHsz',
      appKey: 'XipU873t8gkSypbwl1HWUARD',
      serverURLs: 'https://leancloud.cn/',
    });

    const showCount = (Counter) => {
      const asyncLimit = new AsyncLimit(2);
      $(".leancloud").each(async (e) => {
        const url = $(".leancloud").eq(e).attr('id').trim();
        const query = new AV.Query("Counter");
        query.equalTo("words", url);
        let count = await asyncLimit.run(() => query.count());
        $(".leancloud").eq(e).text(count ? count : '--');
      });
    }

    const addCount = (Counter) => {
      const url = $(".leancloud").length === 1 ? $(".leancloud").attr('id').trim() : 'http://kangshitao.github.io';
      var query = new Counter;
      query.save({
        words: url
      });
    }

    $(function () {
	  const Counter = AV.Object.extend("Counter");
	  showCount(Counter);
      const localhost = /http\:\/\/localhost|http\:\/\/127.0.0.1|http\:\/\/0.0.0.0/;
      if (localhost.test(document.URL)) {
	    return;
	  }
	  addCount(Counter);
    });
  });
</script>





  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>







  <script>
    window.ga = window.ga || function () {
      (ga.q = ga.q || []).push(arguments)
    };
    ga.l = +new Date;
    ga('create', 'G-0FZTGJZNYS', 'auto');
    ga('send', 'pageview');
  </script>
  <script defer src='https://www.google-analytics.com/analytics.js'></script>







</html>